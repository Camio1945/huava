# Summary of ZhengYe's Papers

## 1. 10x Programmer Work Method

### Thinking Framework

Approach any task by asking: "Where are we?", "Where are we going?", and "How can we get there?". This establishes the current state, defines the clear goal, and outlines the path to achieve it.

### Four Core Principles

### Begin with the End in Mind

Always define the true goal before starting work. This prevents wasted effort on tasks that don't align with the ultimate objective.

### Task Decomposition

Break down large, complex goals into small, manageable, and clearly executable tasks. The smaller the task, the easier it is to control and complete.

### Communication & Feedback

Establish clear channels for interaction with others to minimize misunderstandings and ensure information is accurately sent and received.

### Automation

Automate repetitive and tedious tasks to free up human effort for more complex, essential work.

### Definition of Done

Clearly define what "done" means for any task, feature, or iteration. This prevents disagreements and ensures everyone has a shared understanding of completion (e.g., includes coding, testing,
deployment, documentation).

### Acceptance Criteria

Define clear, testable acceptance criteria for each requirement to ensure a shared understanding of the deliverables.

### Continuous Integration

Integrate code frequently (ideally with every commit) to get fast feedback on its correctness and to reduce the complexity of merging changes. Integration itself is part of the coding process.

### Lean Startup & MVP

When dealing with uncertain requirements or new product features, use the Lean Startup approach (Build-Measure-Learn feedback loop) and focus on Minimum Viable Products (MVPs) to validate ideas with
the least amount of effort and cost.

### Work with a Larger Context

Don't limit your perspective to just your immediate coding task. Understand the broader business context, the entire system, and how your work interacts with others. This allows for higher-level
problem-solving and finding simpler solutions.

### Dry Runs/Simulations

Mentally walk through a process (like a deployment) to proactively identify potential issues and refine the plan.

### Measure Your Work

Quantify your goals and progress using metrics and data. Numbers provide an unambiguous standard for "done" and help in making objective decisions.

### Iteration 0

Prepare the foundation of the project (requirements, architecture, CI/CD, etc.) before starting the first development iteration.

### Embrace Small Steps

Tasks should be broken down to a "micro-operation" level where each completed step is small, safe to commit, and provides rapid feedback. This enables continuous adjustment and "embracing change."

### Early Problem Exposure

Expose problems as early as possible, both in code (e.g., parameter validation at the entry point) and in work processes (don't hide issues from teammates/managers). Early detection significantly
reduces the cost of fixing.

### Continuous Improvement

Regularly perform retrospectives or post-mortems to analyze what went well, what didn't, and why. Use techniques like "5 Whys" to get to root causes and implement actionable improvements.

### Listen to Users

Actively seek feedback from actual users (e.g., "eat your own dog food," user testing, customer support rotation). The user's perspective is crucial for building valuable products.

### Structure Your Knowledge

Organize and output your understanding (e.g., writing documentation, giving presentations) to solidify your knowledge and make it more accessible.

### Strategic Laziness

Programmers should be "lazy" in the sense that they strive to automate repetitive tasks and avoid unnecessary work, leading to more efficient solutions.

## 2. The Beauty of Software Design

### Design as Building Models and Specifications

### Model

The core, layered structure of the software that represents its essence, enabling understanding and communication. Good models are "high cohesion, low coupling."

### Specification/Standard

Constraints and guidelines that define *how* requirements should be implemented, ensuring long-term maintainability and consistency.

### Separation of Concerns

The foundational step in software design. Break down problems not just by function, but also by different dimensions (e.g., business logic vs. technical implementation, data variation like read/write
vs. static/dynamic) to manage complexity. The more concerns separated, the better the design.

### Testability as a Primary Design Factor

Design code to be easily testable. Poor testability indicates bad design and leads to higher costs for integration, deployment, and debugging. Testability drives lightweight development.

### Three-Step Approach to Understanding Software Design

### Model

Identify the core concepts and abstractions.

### Interface

Understand how the model's capabilities are exposed (APIs, command lines, DSLs). Analyze interface *style* and *expressiveness*.

### Implementation

Examine the internal details of how the model and interfaces are realized (structure, key technologies).

### Learn a New Language Every Year

Learning different programming languages exposes you to new programming models and ways of thinking.

### All Syntax is Syntactic Sugar

Understand the underlying models and mechanisms of a language, not just its syntax.

### Language Design is Library Design

Good libraries can feel like new language features. Good language design facilitates the creation of good libraries. This is a virtuous cycle.

### Runtime is the Foundation

Understanding the runtime environment (e.g., JVM) allows you to go beyond the limitations of a single language and create more powerful designs.

### Domain-Specific Language

### External DSLs

Have their own syntax (e.g., Regex, Nginx config).

### Internal DSLs

Use the syntax of a host language (e.g., `computer().processor()...`). They make code more expressive by focusing on *what* (intent) rather than *how* (implementation).

### Programming Paradigms

### Structured Programming

Uses control structures (`if/else`, loops) and restricts `goto`. Essential but insufficient for large systems due to strong coupling.

### Object-Oriented Programming

Focuses on objects and their interactions.

### Encapsulation

The core of OOP. Bundles data and behavior. Design based on *behavior*, not exposed data (avoid excessive getters/setters). Minimize external interfaces.

### Inheritance

Primarily for *polymorphism* (interface inheritance), not code reuse (implementation inheritance). Favor composition over inheritance.

### Polymorphism

The "killer feature" of OOP, enabling flexible and decoupled designs by programming to abstractions.

### Functional Programming

Focuses on functions and immutability.

### Compositionality

Building complex functions from simpler ones.

### Immutability

Data, once created, cannot be changed. This simplifies concurrency and reduces bugs.

### Multi-Paradigm Programming

Combine the strengths of different paradigms (e.g., OOP for structure, FP for data transformations).

### SOLID Design Principles (Robert Martin)

### Single Responsibility Principle

A module should have only one reason to change, serving a single "actor" (group of users with shared needs).

### Open/Closed Principle

Software entities should be open for extension but closed for modification, typically achieved through polymorphism.

### Liskov Substitution Principle

Subtypes must be substitutable for their base types without altering the correctness of the program. "IS-A" relationship.

### Interface Segregation Principle

Clients should not be forced to depend on interfaces they don't use. Prefer many small, client-specific interfaces over one large, general-purpose interface.

### Dependency Inversion Principle

High-level modules should not depend on low-level modules; both should depend on abstractions. Abstractions should not depend on details; details should depend on abstractions.

### Simple Design

Avoid over-engineering; build the simplest thing that works.

### Domain-Driven Design (DDD)

### Ubiquitous Language

Use a shared, business-oriented language for both developers and domain experts.

### Strategic Design

Divide a large system into smaller, distinct domain areas with clear boundaries. These boundaries are ideal for microservice decomposition.

### Tactical Design

Model the objects within a bounded context. Entities have identity; Value Objects are immutable and defined by their attributes. Aggregates define consistency boundaries.

## 3. The Ugly Code

### Imprecise Naming

Avoid vague or overly broad names (e.g., `processChapter`, `data`, `info`, `handle`). Names should convey *intent* and *business meaning*, not just low-level details.

### Technical Jargon in Business Logic

Do not use implementation-specific terms (e.g., `bookList`, `redisStore`) in business code where a more abstract business concept (e.g., `books`, `cache`) is appropriate. This indicates a missing
business model.

### Ignoring English Grammar/Semantics

Ensure names follow basic English grammatical rules (e.g., method names are verbs, class names are nouns). Be precise with word choice (`review` vs. `audit`).

### Misspellings and Abbreviations

Avoid typos and non-standard abbreviations. Use IDE spell checkers and a team-wide business glossary for consistent terminology.

### Duplication

### Copy-Paste Code

The most direct form of duplication. Refactor by extracting common logic into reusable functions/methods.

### Structural Duplication

Similar code structures that perform slightly different actions (e.g., multiple `try-catch` blocks with identical error handling). Extract a common pattern (e.g., a template method, higher-order
function).

### Conditional Duplication

`if-else` blocks that are almost identical, differing only by a single parameter or small detail. Consolidate by extracting the differing logic into a variable or separate functions, letting the `if`
make a real choice.

### Long Functions

Functions that are too long (exceeding 10-20 lines as a guideline).

### Causes

Performance misconceptions (avoiding function calls), "flat" sequential coding, incremental additions.

### Solution

Extract methods. Decompose tasks into micro-operations. Use static analysis tools (e.g., CheckStyle `MethodLength`).

### Large Classes

Classes with too many fields and methods.

### Causes

Violations of the Single Responsibility Principle (SRP), grouping unrelated fields.

### Solution

Decompose classes by responsibility (different "actors") and group related fields into separate value objects or embedded types.

### Long Parameter Lists

Functions with too many parameters.

### Solutions

### Introduce Parameter Object

Group related parameters into a new class.

### Separate by Change Frequency

If parameters have different rates of change (static vs. dynamic), move static parameters to be class fields.

### Remove Flag Arguments

Boolean flags in parameter lists often indicate two different behaviors. Split the function into two specialized functions.

### Abusing Control Statements

### Nested Code

Deeply indented `if` or `for` blocks. Reduce nesting using Guard Clauses (early `return` or `throw`). Aim for functions with at most one level of indentation.

### `else` Keyword

Can often be eliminated by using early returns (`return` if a condition is met, otherwise continue).

### Repeated `switch` / `if-else` Chains

Indicates a missing polymorphic model. Replace conditional logic with polymorphism (e.g., strategy pattern, domain objects).

### Loops as Code Smell

Traditional `for`/`while` loops are often imperative "how-to" descriptions. Prefer declarative list transformations (map, filter, reduce) from functional programming.

### Lack of Encapsulation

### Message Chains

`book.getAuthor().getName()`. Exposes internal structure. Solution: Hide Delegate (e.g., `book.getAuthorName()`). Follow the Law of Demeter (talk only to your direct friends).

### Primitive Obsession

Using primitive types (like `double` for price, `String` for date) where a domain-specific object (e.g., `Price`, `DateRange`) is more appropriate. These objects can encapsulate validation and
behavior.

### Excessive Getters/Setters

Especially setters, which expose internal state for arbitrary modification. Prefer behavior-driven methods (`book.approve()` instead of `book.setReviewStatus(...)`).

### Mutable Data

### Solution

Favor immutable objects. If a change is needed, create a new object instance with the updated state.
Minimize mutability where possible.

### Split Initialization

### Solution

Initialize variables immediately upon declaration. Use `final` where applicable. Use declarative collection initializers (e.g., `List.of()`).

### Dependency Chaos

### Missing Anti-Corruption Layer

When external data structures (e.g., `NewBookRequest` for a REST endpoint) are directly used in core business logic. Convert external representations to internal domain-specific objects at the
boundary (e.g., `resource layer` -> `service layer`).

### Concrete Implementations in Business Code

Business logic should depend on abstractions (interfaces), not concrete implementations (e.g., `FeishuSender`, `KafkaProducer`). This violates DIP and couples business logic to changeable technology
details.

### Inconsistent Code Styles/Solutions

Different ways of doing the same thing (e.g., date formatting, utility libraries). Establish team-wide conventions and enforce them. Code within a single function should also be at the same level of
abstraction.

### Outdated Code Style

Sticking to older language features or patterns when newer, more expressive, and safer alternatives exist (e.g., not using `Optional` for null-handling, using traditional loops instead of Streams).

### Code Review

A crucial practice for finding code smells, ensuring correctness (logic, algorithms), and sharing knowledge. Should be frequent and expose issues early. Pair programming is an extreme form.

### New Requirements Breaking Code

Be vigilant when implementing new features. New requirements can inadvertently reintroduce code smells or break existing design principles. Always question if a new interface or entity modification is
truly necessary or if existing abstractions can be reused/extended.

## 4. A Programmer's Course on Testing

### Programmer Testing is Essential

Programmers *must* write tests. It's not just the job of QA.

### Different Perspectives

### Programmers

Focus on white-box testing, unit correctness, and implementation details.

### Testers (QA)

Focus on black-box testing, business requirements, and user perspective.
Programmer tests complement, not replace, QA tests. Well-tested code by developers allows QA to focus on higher-value exploratory testing.

### Automation is Programmer's Strength

Programmers excel at automating tasks, making automated testing a natural fit for them.

### Test Frameworks (xUnit)

Provide structure for automated tests (`@Test`, `@BeforeEach`, `@AfterEach`).

### Assertions are Crucial

Every test must have an assertion to verify an expected outcome. "A test without an assertion is not a good test." Use expressive assertion libraries (AssertJ, Hamcrest).

### Characteristics of Good Tests (A-TRIP)

### Automatic

Automated execution.

### Thorough

Covers all scenarios.

### Repeatable

Consistently produces the same result.

### Independent

Tests do not depend on each other.

### Professional

Test code is production code; maintain quality.

### Simple Tests

Tests should be simple and easy to understand. One test, one specific behavior.

### Testability is a Design Concern

Code that is hard to test indicates poor design.

### "Hard to Test" = Bad Design

If code is hard to test, it often indicates a design flaw.

### Write Testable Code

### Adhere to SOLID principles.

### Composable Code

Use Dependency Injection. Avoid creating dependencies inside a component.

### Avoid Statics, Global State, Singletons

These make code hard to control and mock, hindering testability.

### Isolate Third-Party Code

Use an Anti-Corruption Layer (interfaces wrapping third-party libraries) to separate your business logic from external dependencies, making your core logic testable.

### Thin Callback Layers

When using frameworks that call your code (e.g., Spring Controllers), keep the framework-facing code minimal, delegating quickly to your testable business logic.

### Mock Frameworks

Use Mockito (or similar) to simulate dependencies for unit tests.

### Set expected behavior (`when().thenReturn()`).

### Verify interactions (`verify()`) *sparingly*, as over-verification couples tests to implementation details.

### Unit Tests

### Focus

Single unit (class/method).

### When to Write

Write tests *with* the code, not after. This requires breaking tasks into small, incremental steps.

### Process

Design API -> Identify test scenarios -> Instantiate test cases -> Write minimal code to pass -> Refactor.

### Test Behavior, Not Implementation

Avoid coupling tests too tightly to internal implementation details (e.g., avoid excessive `verify` calls).

### Test Coverage

### A metric to quantify how much of your code is executed by tests.

### Tools

JaCoCo for Java.

### Goals

Aim for 100% coverage on *your own business code*. Isolate and exclude thin layers of hard-to-test third-party code from coverage reports.
Coverage helps find untested branches and logic, but 100% coverage doesn't guarantee bug-free code.

### Integration Tests

### Focus

How components work together (code-to-code) and interact with external systems (code-to-external components like databases, APIs).

### Strategy

Test a full execution path through integrated components.

### Database Integration Tests (Spring Data JPA)

Use framework support (`@DataJpaTest`) to manage database state (e.g., transactional rollback).
Use a dedicated test database (`todo_test`).

### Web API Integration Tests (Spring Boot)

Use `MockMvc` (`@AutoConfigureMockMvc`) for fast, in-memory testing of web layers without a real HTTP server.
`@SpringBootTest` for full application context.
`@WebMvcTest` for testing just the web layer.

### Test Pyramid

The ideal ratio: Many small, fast Unit Tests at the base; fewer, slower Integration Tests in the middle; very few, slowest System/Acceptance Tests at the top.

### Legacy Systems

Often have an "Ice Cream Cone" (many slow system tests, few unit tests). For these, start with high-level tests to build a safety net, then refactor towards the Test Pyramid model.

### "Test Where You Touch"

When working on legacy code, add tests only for the parts you are changing or extending.

### Decoupling is Key

Refactor legacy code to improve testability by breaking dependencies (Extract Method, Extract Delegate, Extract Interface).

### Test-Driven Development (TDD)

### "Red-Green-Refactor" cycle.

More than "write tests first"; it's a *design process*. Tests drive code design towards testability, modularity, and clean interfaces.

### Behavior-Driven Development (BDD)

Focuses on expressing tests in a business-readable language (e.g., Gherkin's Given-When-Then syntax).
Aims to bridge the gap between business stakeholders and technical teams.

### Cucumber

A popular BDD framework.

### Step Definitions

Glue code that connects Gherkin scenarios to actual code implementation.

### Business-Oriented Descriptions

Emphasize describing *what* the system should do from a user's perspective, not *how* it does it.
Often used for acceptance testing.

### Living Documentation

BDD tests can serve as up-to-date documentation.

### Specification by Example (SbE)

Using concrete examples to define requirements.

### "Build Quality In"

Integrate quality checks at every stage of development, rather than relying solely on end-of-process QA.

### No "Unknowing Mistakes" (无知之错) or "Incompetence Mistakes" (无能之错)

Identify if a problem is due to lack of knowledge or failure to apply known practices. Testing helps address both.

### Simple Code

Strive to write clear, concise, and simple code, as it's easier to test, maintain, and understand.

### Continuous Learning & Adaptation

Stay updated with new language features, tools, and best practices. Adapt your testing strategies as the project evolves.

